<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Rust Basic Testing - Bas-Man's Musings</title><meta name=description content="As I work through learning rust, I figured it was time to to start doing actual testing.
Why Test Simple, it&rsquo;s really essential when building anything beyond a few lines of simple code. Being able to run a series of reproducible tests as you develop; allows you to ensure that changes you make are not breaking exisiting code. You also have the option to develop using TDD.
Of course I have not adhered to any of this as I explore the basics of working with rust."><meta name=author content="Bas-Man"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Bas-Man\u0027s Musings","url":"https:\/\/bas-man.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/bas-man.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/bas-man.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/bas-man.github.io\/post\/rust\/rust-basic-testing\/","name":"Rust basic testing"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Bas-Man"},"headline":"Rust Basic Testing","description":"As I work through learning rust, I figured it was time to to start doing actual testing.\nWhy Test Simple, it\u0026rsquo;s really essential when building anything beyond a few lines of simple code. Being able to run a series of reproducible tests as you develop; allows you to ensure that changes you make are not breaking exisiting code. You also have the option to develop using TDD.\nOf course I have not adhered to any of this as I explore the basics of working with rust.","inLanguage":"en","wordCount":1070,"datePublished":"2021-04-19T15:00:00","dateModified":"2021-04-19T15:00:00","image":"https:\/\/bas-man.github.io\/","keywords":["rust, basic, testing, learning"],"mainEntityOfPage":"https:\/\/bas-man.github.io\/post\/rust\/rust-basic-testing\/","publisher":{"@type":"Organization","name":"https:\/\/bas-man.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/bas-man.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Rust Basic Testing"><meta property="og:description" content="As I work through learning rust, I figured it was time to to start doing actual testing.
Why Test Simple, it&rsquo;s really essential when building anything beyond a few lines of simple code. Being able to run a series of reproducible tests as you develop; allows you to ensure that changes you make are not breaking exisiting code. You also have the option to develop using TDD.
Of course I have not adhered to any of this as I explore the basics of working with rust."><meta property="og:url" content="https://bas-man.github.io/post/rust/rust-basic-testing/"><meta property="og:type" content="website"><meta property="og:site_name" content="Bas-Man's Musings"><meta name=twitter:title content="Rust Basic Testing"><meta name=twitter:description content="As I work through learning rust, I figured it was time to to start doing actual testing.
Why Test Simple, it&rsquo;s really essential when building anything beyond a few lines of simple code. Being â€¦"><meta name=twitter:card content="summary"><link href=https://bas-man.github.io/images/favicons/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.83.1"><link rel=alternate href=https://bas-man.github.io/index.xml type=application/rss+xml title="Bas-Man's Musings"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://bas-man.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://bas-man.github.io/css/highlight.min.css><link rel=stylesheet href=https://bas-man.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=/css/custom.css><link href=/css/boxes.css rel=stylesheet><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-166598762-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-CBZDLNDS8F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-CBZDLNDS8F')</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://bas-man.github.io/>Bas-Man's Musings</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Home href=/>Home</a></li><li class=navlinks-container><a class=navlinks-parent>Categories</a><div class=navlinks-children><a href=/series>Series</a>
<a href=/categories>Categories</a>
<a href=/tags>Tags</a></div></li><li class=navlinks-container><a class=navlinks-parent>Projects</a><div class=navlinks-children><a href=/projects/github/>GitHub</a>
<a href=/projects/line-notify-from-email/>Line Notification</a></div></li><li class=navlinks-container><a class=navlinks-parent>Docs</a><div class=navlinks-children><a href=/docs/bind-dns-setup/>Bind DNS Setup</a>
<a href=/docs/gmail-zapier-line-notify/>Gmail & Zapier</a></div></li><li class=navlinks-container><a class=navlinks-parent>References</a><div class=navlinks-children><a href=/cheatsheets/python/>Python</a>
<a href=/cheatsheets/perl/>Perl</a>
<a href=/cheatsheets/rust/>Rust</a>
<a href=/cheatsheets/git/>Git</a>
<a href=/cheatsheets/latex/>LaTeX</a></div></li><li class=navlinks-container><a class=navlinks-parent>Snippets</a><div class=navlinks-children><a href=/cheatsheets/python/snippets/>Python</a>
<a href=/cheatsheets/perl/snippets/>Perl</a>
<a href=/cheatsheets/rust/snippets/>Rust</a>
<a href=/cheatsheets/git/snippets/>Git</a></div></li><li><a title=About href=/about/>About</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Rust Basic Testing</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on April 19, 2021
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;6&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1070&nbsp;words
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Bas-Man</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>As I work through learning <strong>rust</strong>, I figured it was time to to start doing actual testing.</p><h2 id=why-test>Why Test</h2><p>Simple, it&rsquo;s really essential when building anything beyond a few lines of simple code. Being able to run a series of reproducible tests as you develop; allows you to ensure that changes you make are not breaking exisiting code. You also have the option to develop using <strong>TDD</strong>.<br>Of course I have not adhered to any of this as I explore the basics of working with rust. But things are progressing and I should now see how testing basically works in the world of rust.</p><p>I am going to just cover the style of testing that I have played with so far. For more information, I refer to you to <a href=https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html>the book</a>. Also be aware this not about how to test code. It&rsquo;s more about how tests can be integrated into code as you develop in the rust environment.</p><h2 id=basic-inline-testing>Basic inline testing</h2><p>Let&rsquo;s start with the basic testing. Here we just add a test in the same file as the function we want to test.<br>Looking at <code>dns/spf/mod.rs</code> we find the following code at the end of the file.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>remove_qualifier</span><span class=p>(</span><span class=n>record</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// Remove leading (+,-,~,?) character and return an updated str
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>chars</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=n>chars</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>chars</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>chars</span><span class=p>.</span><span class=n>as_str</span><span class=p>()</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_remove_qualifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>test_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;abc&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>remove_qualifier</span><span class=p>(</span><span class=n>test_str</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>result</span><span class=p>,</span><span class=w> </span><span class=s>&#34;bc&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We have a function called <code>remove_qualifier()</code> which takes a reference to a <code>slice</code>.
According to the comment, it removes the leading <code>char</code> and returns a reference to the new str.<br>Directly below that we have the <code>#[test]</code> followed by a new function called <code>test_remove_qualifier()</code>. This is the test function.</p><ul><li>It creates a slice containing <em>abc</em></li><li>Passes it to remove_qualifier which returns a slice back to <code>result</code></li><li>Then we check using an <code>assert_eq!</code> macro that <code>result</code> actually does match our expected slice of <code>bc</code></li></ul><p>We can run this test using <strong>cargo test</strong> in the terminal. I have removed some output from other tests that already exists.</p><h4 id=test-output>Test Output</h4><div class=highlight><pre class=chroma><code class=language-zsh data-lang=zsh>&gt; cargo <span class=nb>test</span>
snip...
<span class=nb>test</span> dns::spf::test_remove_qualifier ... ok
snip...
</code></pre></div><p>Let&rsquo;s take a look at some more examples.</p><p>In the same file we have the following function and a of tests. This function actually uses <strong>remove_qualifier()</strong></p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// Check if the initial character in the string `record` matches `c`
</span><span class=c1>// If they do no match then return the initial character
</span><span class=c1>// if c matches first character of record, we can `+`, a blank modiifer equates to `+`
</span><span class=c1></span><span class=k>fn</span> <span class=nf>return_and_remove_qualifier</span><span class=p>(</span><span class=n>record</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>c</span>: <span class=nc>char</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=n>char</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// Returns a tuple of (qualifier, &amp;str)
</span><span class=c1></span><span class=w>    </span><span class=c1>// &amp;str will have had the qualifier character removed if it existed. The &amp;str will be unchanged
</span><span class=c1></span><span class=w>    </span><span class=c1>// if the qualifier was not present
</span><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>nth</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>unwrap</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// qualifier exists. return tuple of qualifier and `record` with qualifier removed.
</span><span class=c1></span><span class=w>        </span><span class=p>(</span><span class=n>record</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>nth</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=n>remove_qualifier</span><span class=p>(</span><span class=n>record</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// qualifier does not exist, default to `+` and return unmodified `record`
</span><span class=c1></span><span class=w>        </span><span class=p>(</span><span class=sc>&#39;+&#39;</span><span class=p>,</span><span class=w> </span><span class=n>record</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_return_and_remove_qualifier_no_qualifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;no prefix&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_and_remove_qualifier</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=sc>&#39;+&#39;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_return_and_remove_qualifier_pass</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;+prefix&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_and_remove_qualifier</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=sc>&#39;+&#39;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;prefix&#34;</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_return_and_remove_qualifier_fail</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;-prefix&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_and_remove_qualifier</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=sc>&#39;-&#39;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;prefix&#34;</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_return_and_remove_qualifier_softfail</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;~prefix&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_and_remove_qualifier</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=sc>&#39;~&#39;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;prefix&#34;</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_return_and_remove_qualifier_neutral</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;?prefix&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_and_remove_qualifier</span><span class=p>(</span><span class=n>source</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;n&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=sc>&#39;?&#39;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;prefix&#34;</span><span class=p>,</span><span class=w> </span><span class=n>new_str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>I should point out, that each test function is preceeded by <em>#[test]</em>. I have also seen it written as:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[test]</span><span class=w> </span><span class=k>fn</span> <span class=p>......()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>  </span><span class=n>code</span><span class=w> 
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>These test the five possible cases,</p><ol><li>No prefix present. A default prefix of <code>+</code> is returned along with an unmodified slice</li><li><code>+</code> prefix present, <code>+</code> and a modified slice is returned</li><li><code>-</code> prefix present, <code>-</code> and a modified slice is returned</li><li><code>~</code> prefix present, <code>~</code> and a modified slice is returned</li><li><code>?</code> prefix present, <code>?</code> and a modified slice is returned</li></ol><h4 id=test-output-1>Test Output</h4><div class=highlight><pre class=chroma><code class=language-zsh data-lang=zsh>&gt; cargo <span class=nb>test</span>
snip...
<span class=nb>test</span> dns::spf::test_return_and_remove_qualifier_fail ... ok
<span class=nb>test</span> dns::spf::test_return_and_remove_qualifier_neutral ... ok
<span class=nb>test</span> dns::spf::test_return_and_remove_qualifier_no_qualifier ... ok
<span class=nb>test</span> dns::spf::test_return_and_remove_qualifier_pass ... ok
<span class=nb>test</span> dns::spf::test_return_and_remove_qualifier_softfail ... ok
</code></pre></div><p>This is the quick easy way to introduce tests. The test will only be run when we run <strong>cargo test</strong> in the terminal. The down side here is, if you need to make use of a library for testing purposes only. Rust will complain about an unused library at compile time.</p><h2 id=basic-module-testing>Basic module testing</h2><p>Another way to do testing is to create tests as a module.<br>For this let&rsquo;s take a look at the <code>spf_test.rs</code> located under <code>src/dns/spf</code></p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>test_spf</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>dns</span>::<span class=n>spf</span>::<span class=n>Spf</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>test_redirect</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;v=spf1 redirect=_spf.google.com&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>spf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Spf</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>input</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>input</span><span class=p>,</span><span class=w> </span><span class=n>spf</span><span class=p>.</span><span class=n>source</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=n>spf</span><span class=p>.</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>is_redirect</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>include</span><span class=p>.</span><span class=n>is_none</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>a</span><span class=p>.</span><span class=n>is_none</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>mx</span><span class=p>.</span><span class=n>is_none</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>ip4</span><span class=p>.</span><span class=n>is_none</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>ip6</span><span class=p>.</span><span class=n>is_none</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>test_hotmail</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;v=spf1 ip4:157.55.9.128/25 include:spf.protection.outlook.com include:spf-a.outlook.com include:spf-b.outlook.com include:spf-a.hotmail.com include:_spf-ssg-b.microsoft.com include:_spf-ssg-c.microsoft.com ~all&#34;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>spf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Spf</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>input</span><span class=p>.</span><span class=n>to_string</span><span class=p>());</span><span class=w>
</span><span class=w>      </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>input</span><span class=p>,</span><span class=w> </span><span class=n>spf</span><span class=p>.</span><span class=n>source</span><span class=p>());</span><span class=w>
</span><span class=w>      </span><span class=n>spf</span><span class=p>.</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>      </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>is_redirect</span><span class=p>(),</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>      </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>!</span><span class=n>spf</span><span class=p>.</span><span class=n>includes</span><span class=p>().</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>is_empty</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span><span class=w>      </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>includes</span><span class=p>().</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>len</span><span class=p>(),</span><span class=w> </span><span class=mi>6</span><span class=p>);</span><span class=w>
</span><span class=w>      </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>          </span><span class=n>spf</span><span class=p>.</span><span class=n>includes</span><span class=p>().</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()[</span><span class=mi>0</span><span class=p>].</span><span class=n>as_mechanism</span><span class=p>(),</span><span class=w>
</span><span class=w>          </span><span class=s>&#34;include:spf.protection.outlook.com&#34;</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>spf</span><span class=p>.</span><span class=n>ip4</span><span class=p>().</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>len</span><span class=p>(),</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>          </span><span class=n>spf</span><span class=p>.</span><span class=n>ip4</span><span class=p>().</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()[</span><span class=mi>0</span><span class=p>].</span><span class=n>as_mechanism</span><span class=p>(),</span><span class=w>
</span><span class=w>          </span><span class=s>&#34;ip4:157.55.9.128/25&#34;</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>spf</span><span class=p>.</span><span class=n>all</span><span class=p>(),</span><span class=w> </span><span class=sc>&#39;~&#39;</span><span class=p>);</span><span class=w>
</span><span class=w>      </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=c1>//snip...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now there is an independent file for testing.
In order to test the <strong>Spf</strong> struct and functions we need to <strong>use</strong> it in the module. So we write <code>use crate::dns::spf::Spf</code> and we now have access to this code in this testing file.</p><p>Now we can write our series of test functions.</p><p>I will just talk about the <em>hotmail</em> example here.
We have a known string which represents hotmail&rsquo;s current SPF record at the time of this article. It contains one <strong>ip4</strong> mechanism and 6 <strong>include</strong> mechanisms.<br>I am checking the following items:</p><ol><li>input and spf.source match</li><li>is_redirect() is false</li><li>includes() is NOT empty</li><li>includes() contains <strong>6</strong> items</li><li>The first time <strong>[0]</strong> matches <strong>include:spf.protection.outlook.com</strong></li><li>I then test the same things with ip4,<ol><li>There is <strong>one</strong> item</li><li>The first item matches <strong>ip4:157.55.9.128/25</strong></li></ol></li><li>Finally I check that the qualifier was also parsed correctly.</li></ol><h4 id=test-output-2>Test Output</h4><div class=highlight><pre class=chroma><code class=language-zsh data-lang=zsh><span class=nb>test</span> dns::spf::spf_test::test_spf::test_hotmail ... ok
<span class=nb>test</span> dns::spf::spf_test::test_spf::test_netblocks2_google_com ... ok
<span class=nb>test</span> dns::spf::spf_test::test_spf::test_redirect ... ok
</code></pre></div><p>If you do not want to place tests in a single file, you can also place them in the source file of the module you wish to test. Take a look at <code>dns/spf/mechanism.rs</code></p><h3 id=conditional-compilation>Conditional Compilation</h3><p>For me, one of the big advantages I see is using the <code>mod</code> form for testing and conditional compilation.</p><p>During one of experiments, I thought it would be cool to test if two pointers were point to the same memory address. For this I needed <code>std::ptr::eq</code>. I figured I would just add it to the top of my imports. Then I could use it in my test functions.</p><p>Great that worked, but during a normal compile, rust would complain saying I had an unused import. This was because I was only making use of the library in my test functions and not in my normal functions. And the library was visible throughout the file.</p><p>The solution was to move the importing of the library into the testing module. Be aware this can not be done if you are just placing tests within the basic coding file as in the initial example.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>SpfMechanismString</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>SpfMechanism</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ptr</span><span class=p>;</span><span class=w> </span><span class=c1>// Now scoped within SpfMechanismString
</span><span class=c1></span><span class=w>    </span><span class=c1>//snip....
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>By positioning the import here. The library is only compiled into the code during testing and is not included during a normal compile. No more warning about an unused library.</p><h2 id=conclusion>Conclusion</h2><p>I know this is all pretty simple stuff. But it was something new to learn. The conditional compilation was probably the most interesting thing.</p><p>You can find the code related to this aritcle <a href=https://github.com/Bas-Man/learning-rust-trust-dns-resolver/tree/BASIC-TESTING>here</a></p><div class=blog-tags><a href=https://bas-man.github.io//tags/rust/>rust</a>&nbsp;
<a href=https://bas-man.github.io//tags/basic/>basic</a>&nbsp;
<a href=https://bas-man.github.io//tags/testing/>testing</a>&nbsp;
<a href=https://bas-man.github.io//tags/learning/>learning</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f&text=Rust%20Basic%20Testing&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f&title=Rust%20Basic%20Testing" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f&title=Rust%20Basic%20Testing" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f&title=Rust%20Basic%20Testing" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fbas-man.github.io%2fpost%2frust%2frust-basic-testing%2f&description=Rust%20Basic%20Testing" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>See also</h4><ul><li><a href=/cheatsheets/git/snippets/prevent-cpantesters-from-testing-set-os/>Prevent CPAN-Testers from testing under certain OS</a></li><li><a href=/cheatsheets/rust/snippets/trust-dns-resolver-mx/>Using trust-dns-resolver to do mx lookups</a></li><li><a href=/cheatsheets/rust/snippets/trust-dns-resolver-soa/>Using trust-dns-resolver to do soa lookups</a></li><li><a href=/post/swift/swift-spf-documenting-package/>Swift: Deconstruct SPF</a></li><li><a href=/post/swift/swift-spf-asmechanism-using-qualifier/>Swift: Deconstruct SPF: asMechanism with Qualifier</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://bas-man.github.io/post/rust/manage-rust-code-by-breaking-it-up/ data-toggle=tooltip data-placement=top title="Manage Rust Code by Breaking it Up">&larr; Previous Post</a></li><li class=next><a href=https://bas-man.github.io/post/rust/rust-looking-at-regex/ data-toggle=tooltip data-placement=top title="Looking at Regex in Rust">Next Post &rarr;</a></li></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/Bas-Man title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://dev.to/basman title=Dev><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-dev fa-stack-1x fa-inverse"></i></span></a></li><li><a href="https://flipboard.com/@baspann/coding-kq8v8rh8z?from=share%25!%28EXTRA%20string=%29" title=Flipboard><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-flipboard fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">Bas-Man
&nbsp;&bull;&nbsp;&copy;
2020 - 2021
&nbsp;&bull;&nbsp;
<a href=https://bas-man.github.io/>Bas-Man's Musings</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.83.1</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://bas-man.github.io/js/main.js></script><script src=https://bas-man.github.io/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://bas-man.github.io/js/load-photoswipe.js></script><div class=cookie-container><p>By using this site, you agree to our use of cookies.
We use cookies on this website to give you the best experience on our
site. To find out more, read our <a href=/privacy/>privacy</a> policy.</p><button class=cookie-btn>
Okay</button></div><script src=/js/custom.js></script></body></html>