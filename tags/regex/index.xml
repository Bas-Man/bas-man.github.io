<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>regex on Bas-Man's Musings</title><link>https://bas-man.github.io/tags/regex/</link><description>Recent content in regex on Bas-Man's Musings</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 22 Apr 2021 14:30:00 +0900</lastBuildDate><atom:link href="https://bas-man.github.io/tags/regex/index.xml" rel="self" type="application/rss+xml"/><item><title>Return a dictionary of Regex Matches</title><link>https://bas-man.github.io/cheatsheets/python/snippets/multiple-group-regex/</link><pubDate>Tue, 12 Jan 2021 16:00:00 +0900</pubDate><guid>https://bas-man.github.io/cheatsheets/python/snippets/multiple-group-regex/</guid><description>An example of how to make your function more flexible to handle a different number of return values. This means you won&amp;rsquo;t have to write the same code repeatedly if you are only changing the number of groups that are being returned.
def findMatches(string, regex) -&amp;gt; dict: &amp;#34;&amp;#34;&amp;#34; This is a generic matching function. Warning! Your regex expression MUST use &amp;#39;Named Groups&amp;#39; -&amp;gt; (:P&amp;lt;name&amp;gt;) or this function will return an empty dictionary :param string: The text you are searching :type string: str :param regex: The regular expression string you are using to search :type regex: str :returns: A dictionary of named key/value pairs.</description></item><item><title>Looking at Regex in Rust (Addendum)</title><link>https://bas-man.github.io/post/rust/rust-looking-at-regex-addendum/</link><pubDate>Thu, 22 Apr 2021 14:30:00 +0900</pubDate><guid>https://bas-man.github.io/post/rust/rust-looking-at-regex-addendum/</guid><description>Hi. In my previous article Looking at Regex in Rust. I covered some basics. Today I will go over some new things that I have learned, as I expanded on things that my regex expression needs to handle. In particular the need to handle the possible existence or none existence of qualifiers +,-,~,?.
TL;DR: If you don&amp;rsquo;t want to read the full article. I will place the highlights here.
A regex pattern such as (x?</description></item><item><title>Looking at Regex in Rust</title><link>https://bas-man.github.io/post/rust/rust-looking-at-regex/</link><pubDate>Tue, 20 Apr 2021 21:58:40 +0900</pubDate><guid>https://bas-man.github.io/post/rust/rust-looking-at-regex/</guid><description>If you have been following this series, you might know that I am playing with SPF records. I have turned my eye to a and mx mechanisms. As I started looking at the a mechanism. I noticed that my current approach using the standard string functions would probably be fairly difficult to implement. So I started to think about using the Regex crate. So this will be a look at how that went.</description></item><item><title>Generic Regex Match Function Multiple Groups</title><link>https://bas-man.github.io/post/generic-regex-match-function-multiple-groups/</link><pubDate>Tue, 12 Jan 2021 16:00:00 +0900</pubDate><guid>https://bas-man.github.io/post/generic-regex-match-function-multiple-groups/</guid><description>If you have read my previous posts; you might know I am currently working on a new project to move some services to a self-hosted solution. As part of this, I have been working on dealing with unicode characters in regex.
In relation to this I have found that I am writing the same function repeatedly. The only difference being the number matches being returned. So I decided we need to refactor this.</description></item><item><title>Working with double-byte regex expressions with Python3</title><link>https://bas-man.github.io/post/regex-double-byte-python3/</link><pubDate>Tue, 05 Jan 2021 12:00:00 +0900</pubDate><guid>https://bas-man.github.io/post/regex-double-byte-python3/</guid><description>As part of my project Self Hosted Zapier Alternative; I am having to deal with doing regex searches against the three Japanese written forms, Kanji, Hiragana and Katakana.
Fortunately this is a common problem. So I have found some references for this. Also one of my favourite tools for developing regex expressions, Regex101, also offers support in this area.
I found this useful Github Gist.
note:
You should also check the gist directly as there are some follow up comments and additions.</description></item></channel></rss>